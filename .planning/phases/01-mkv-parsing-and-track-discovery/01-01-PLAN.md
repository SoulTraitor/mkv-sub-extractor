---
phase: 01-mkv-parsing-and-track-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - pkg/mkvinfo/types.go
  - pkg/mkvinfo/codec.go
  - pkg/mkvinfo/codec_test.go
  - pkg/mkvinfo/language.go
  - pkg/mkvinfo/language_test.go
  - pkg/mkvinfo/format.go
  - pkg/mkvinfo/format_test.go
  - pkg/mkvinfo/mkvinfo.go
  - pkg/mkvinfo/mkvinfo_test.go
autonomous: true

must_haves:
  truths:
    - "MKV file can be opened and its EBML header parsed without error"
    - "All subtitle tracks are enumerated from the Tracks element with correct metadata"
    - "Codec IDs are classified into human-readable format types with text/image distinction"
    - "ISO 639-2 language codes resolve to native-script human-readable names"
    - "File size formats as human-readable string (e.g. 1.2 GB)"
    - "Duration formats as H:MM:SS with zero/absent handled as Unknown"
  artifacts:
    - path: "go.mod"
      provides: "Go module definition with matroska-go and x/text dependencies"
      contains: "github.com/luispater/matroska-go"
    - path: "pkg/mkvinfo/types.go"
      provides: "FileInfo and SubtitleTrack structs"
      contains: "type FileInfo struct"
    - path: "pkg/mkvinfo/codec.go"
      provides: "Codec ID classification map and function"
      contains: "codecMap"
    - path: "pkg/mkvinfo/language.go"
      provides: "ISO 639-2 to display name resolution"
      contains: "resolveLanguageName"
    - path: "pkg/mkvinfo/format.go"
      provides: "File size and duration formatting utilities"
      contains: "formatFileSize"
    - path: "pkg/mkvinfo/mkvinfo.go"
      provides: "Core MKV parsing logic using matroska-go Demuxer"
      contains: "func GetMKVInfo"
  key_links:
    - from: "pkg/mkvinfo/mkvinfo.go"
      to: "matroska-go Demuxer"
      via: "matroska.NewDemuxer(file)"
      pattern: "matroska\\.NewDemuxer"
    - from: "pkg/mkvinfo/mkvinfo.go"
      to: "pkg/mkvinfo/codec.go"
      via: "classifyCodec call for each track"
      pattern: "classifyCodec\\(info\\.CodecID\\)"
    - from: "pkg/mkvinfo/mkvinfo.go"
      to: "pkg/mkvinfo/language.go"
      via: "resolveLanguageName call for each track"
      pattern: "resolveLanguageName\\(info\\.Language\\)"
---

<objective>
Set up the Go project and implement the core MKV parsing package that opens MKV files, enumerates subtitle tracks with metadata, classifies codec types, resolves language names, and formats file metadata.

Purpose: This is the foundational package that all display and CLI code will build on. It transforms raw matroska-go library output into our domain types (FileInfo, SubtitleTrack).
Output: Working `pkg/mkvinfo` package with types, parsing, codec classification, language resolution, and formatting utilities -- all with unit tests.
</objective>

<execution_context>
@C:/Users/SOUL/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/SOUL/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-mkv-parsing-and-track-discovery/01-CONTEXT.md
@.planning/phases/01-mkv-parsing-and-track-discovery/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and create domain types</name>
  <files>
    go.mod
    go.sum
    pkg/mkvinfo/types.go
  </files>
  <action>
1. Initialize the Go module:
   ```
   go mod init mkv-sub-extractor
   go get github.com/luispater/matroska-go@v1.2.4
   go get golang.org/x/text@latest
   ```

2. Create `pkg/mkvinfo/types.go` (package `mkvinfo`) with two exported types:

   `FileInfo` struct with fields:
   - FileName string
   - FileSize int64 (bytes)
   - Duration time.Duration (from SegmentInfo.Duration nanoseconds)
   - SubtitleCount int (total subtitle tracks including image-based)
   - TextSubCount int (extractable text subtitle tracks only)

   `SubtitleTrack` struct with fields:
   - Number uint8 (Matroska TrackNumber -- the real track identifier, NOT the array index)
   - Index int (display index, 1-based sequential for our listing)
   - Language string (raw ISO 639-2 code from Matroska, e.g. "eng", "jpn")
   - LanguageName string (resolved human-readable name, e.g. "English", "中文")
   - FormatType string (human-readable: "SRT", "ASS", "SSA", "PGS", etc.)
   - CodecID string (raw Matroska codec ID, e.g. "S_TEXT/UTF8")
   - Name string (track name from metadata, may be empty)
   - IsDefault bool (FlagDefault)
   - IsForced bool (FlagForced)
   - IsText bool (true for S_TEXT/* codecs)
   - IsExtractable bool (true if text-based and extractable)

   `MKVInfo` struct that bundles FileInfo + []SubtitleTrack for return from the main parsing function.

Note: These types exactly match the research recommendations. Do NOT add fields not listed here.
  </action>
  <verify>
Run `go build ./...` from project root -- must compile with no errors. Verify `go.mod` contains both `matroska-go` and `x/text` dependencies.
  </verify>
  <done>
go.mod exists with correct module name and dependencies. types.go compiles. FileInfo, SubtitleTrack, and MKVInfo types are exported and usable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement codec classification, language resolution, and formatting utilities</name>
  <files>
    pkg/mkvinfo/codec.go
    pkg/mkvinfo/codec_test.go
    pkg/mkvinfo/language.go
    pkg/mkvinfo/language_test.go
    pkg/mkvinfo/format.go
    pkg/mkvinfo/format_test.go
  </files>
  <action>
1. Create `pkg/mkvinfo/codec.go`:
   - Define unexported `codecInfo` struct: `FormatType string`, `IsText bool`
   - Define package-level `codecMap` (map[string]codecInfo) with these entries verified from Matroska subtitle spec:
     - "S_TEXT/UTF8" -> FormatType:"SRT", IsText:true
     - "S_TEXT/SSA" -> FormatType:"SSA", IsText:true
     - "S_TEXT/ASS" -> FormatType:"ASS", IsText:true
     - "S_TEXT/WEBVTT" -> FormatType:"WebVTT", IsText:true
     - "S_TEXT/USF" -> FormatType:"USF", IsText:true
     - "S_HDMV/PGS" -> FormatType:"PGS", IsText:false
     - "S_VOBSUB" -> FormatType:"VobSub", IsText:false
     - "S_DVBSUB" -> FormatType:"DVB", IsText:false
     - "S_HDMV/TEXTST" -> FormatType:"HDMV Text", IsText:true
     - "S_ARIBSUB" -> FormatType:"ARIB", IsText:true
   - Export function `ClassifyCodec(codecID string) (formatType string, isText bool)`:
     - Lookup in codecMap. If found, return values.
     - If NOT found: return formatType=codecID (raw ID as-is), isText=false. NEVER panic on unknown codec.

2. Create `pkg/mkvinfo/codec_test.go`:
   - Test all known codec IDs return correct FormatType and IsText.
   - Test unknown codec ID (e.g. "S_UNKNOWN/FOO") returns the raw ID and isText=false.
   - Test empty string returns empty string and isText=false.

3. Create `pkg/mkvinfo/language.go`:
   - Export function `ResolveLanguageName(code string) string`:
     - If code is "" or "und" -> return "Unknown" (per user locked decision)
     - Parse with `language.ParseBase(code)`. If error -> return raw code string.
     - Make tag with `language.Make(base.String())`
     - Try `display.Self.Name(tag)` first (native-script: "中文", "日本語")
     - Fallback to `display.English.Languages().Name(tag)`
     - Final fallback: return raw code string
   - Import `golang.org/x/text/language` and `golang.org/x/text/language/display`

4. Create `pkg/mkvinfo/language_test.go`:
   - Test "eng" -> "English"
   - Test "chi" -> should resolve to Chinese (native script, likely "中文")
   - Test "jpn" -> should resolve to Japanese (native script)
   - Test "fre" -> should resolve to French (bibliographic code)
   - Test "ger" -> should resolve to German (bibliographic code)
   - Test "und" -> "Unknown"
   - Test "" -> "Unknown"
   - Test "zzz" (invalid) -> returns "zzz" (raw code fallback)

5. Create `pkg/mkvinfo/format.go`:
   - Export function `FormatFileSize(bytes int64) string`:
     - Negative -> "Unknown"
     - < 1024 -> "N B"
     - Otherwise -> "X.X KB/MB/GB/TB" using 1024-based units
   - Export function `FormatDuration(d time.Duration) string`:
     - d <= 0 -> "Unknown"
     - Otherwise -> "H:MM:SS" format (e.g. "1:42:30", "0:05:12")

6. Create `pkg/mkvinfo/format_test.go`:
   - FormatFileSize: test 0, 500, 1024, 1073741824 (1 GB), 1288490189 (~1.2 GB), -1
   - FormatDuration: test 0, negative, 5m12s, 1h42m30s, 25h0m0s (>24h)
  </action>
  <verify>
Run `go test ./pkg/mkvinfo/ -v -run "TestClassify|TestResolve|TestFormat"` -- all tests must pass. Run `go vet ./...` for static analysis.
  </verify>
  <done>
All codec IDs correctly classified. Language codes resolve to native-script names. File size and duration format correctly. All unit tests pass. Unknown/edge cases handled gracefully (no panics).
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement core MKV parsing function using matroska-go</name>
  <files>
    pkg/mkvinfo/mkvinfo.go
    pkg/mkvinfo/mkvinfo_test.go
  </files>
  <action>
1. Create `pkg/mkvinfo/mkvinfo.go`:
   - Export function `GetMKVInfo(path string) (*MKVInfo, error)` that:
     a. Opens the file with `os.Open(path)`. Wraps errors with context: `fmt.Errorf("cannot open file: %w", err)`
     b. Defers file.Close()
     c. Gets file stat for size: `file.Stat()`
     d. Creates demuxer: `matroska.NewDemuxer(file)`. If error, wrap: `fmt.Errorf("not a valid MKV file: %w", err)`
     e. Defers demuxer.Close()
     f. Gets segment info: `demuxer.GetFileInfo()`. Duration = `time.Duration(segInfo.Duration)`. If Duration is 0, keep it as 0 (FormatDuration will handle "Unknown").
     g. Enumerates all tracks with `demuxer.GetNumTracks()` + loop `demuxer.GetTrackInfo(i)`:
        - Skip non-subtitle tracks: `info.Type != 17` (matroska.TypeSubtitle -- verify the constant exists, if not use literal 17)
        - For each subtitle track, call `ClassifyCodec(info.CodecID)` and `ResolveLanguageName(info.Language)`
        - Build SubtitleTrack struct with all fields populated
        - Assign sequential `Index` (1-based) across ALL subtitle tracks (both text and image)
     h. Counts total subtitle tracks and text-only subtitle tracks
     i. Returns `&MKVInfo{Info: fileInfo, Tracks: tracks}`

   - Handle the PITFALL about FlagDefault: The matroska-go library returns `info.Default` which reflects the Matroska default (true if element absent). Pass through as-is -- display logic in Plan 02 will handle smart display.

   - Handle the PITFALL about TrackNumber vs Index: Store `info.Number` as `Number` (Matroska track number) and our sequential counter as `Index` (display index). These may differ.

   - Import `matroska "github.com/luispater/matroska-go"` (aliased import per research convention).

2. Create `pkg/mkvinfo/mkvinfo_test.go`:
   - Since we cannot include real MKV files in tests, create a test that verifies the function returns a clear error for a non-existent file path.
   - Create a test that verifies the function returns a clear error for a non-MKV file (create a temp file with random bytes, pass to GetMKVInfo, expect "not a valid MKV file" error).
   - Add a comment noting that integration testing with real MKV files should be done manually: `go run ./cmd/mkv-sub-extractor/main.go path/to/test.mkv`

3. Run `go mod tidy` to clean up go.sum.
  </action>
  <verify>
Run `go test ./pkg/mkvinfo/ -v` -- all tests pass. Run `go build ./pkg/mkvinfo/` -- package compiles. Run `go vet ./...` -- no issues. Verify go.mod and go.sum are clean after `go mod tidy`.
  </verify>
  <done>
GetMKVInfo function compiles and integrates all sub-functions (ClassifyCodec, ResolveLanguageName). Error paths tested. Package builds cleanly. Ready for display layer to consume MKVInfo struct.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` passes with no errors
2. `go test ./pkg/mkvinfo/ -v` -- all unit tests pass
3. `go vet ./...` -- no static analysis issues
4. go.mod contains `github.com/luispater/matroska-go` and `golang.org/x/text`
5. Package exports: GetMKVInfo, ClassifyCodec, ResolveLanguageName, FormatFileSize, FormatDuration, FileInfo, SubtitleTrack, MKVInfo
</verification>

<success_criteria>
- The `pkg/mkvinfo` package compiles and all tests pass
- GetMKVInfo accepts a file path and returns structured MKVInfo (or error)
- Codec classification covers all 10 standard Matroska subtitle codec IDs plus graceful fallback for unknown IDs
- Language resolution converts ISO 639-2 codes to native-script names (verified for eng, chi, jpn, fre, ger)
- File size and duration formatting produce human-readable strings
- No panics on edge cases (unknown codec, invalid language, zero duration, non-MKV file)
</success_criteria>

<output>
After completion, create `.planning/phases/01-mkv-parsing-and-track-discovery/01-01-SUMMARY.md`
</output>
